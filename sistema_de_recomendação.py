# -*- coding: utf-8 -*-
"""Sistema de Recomendação

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wsBnt4Gn2bBOI-dLYvWwq66b1ZGTw5te

## Sistema de Recomendação de Livros

Um sistema de recomendação é uma classe de aprendizado de maquina usado para sugerir itens ou conteúdos aos usuários com base em dados coletados sobre o comportamento deles e/ou de outros usuários. O principal objetivo é personalizar a experiência do usuário, oferecendo sugestões que atendam às suas preferências, necessidades ou interesses, de forma a aumentar a satisfação e o engajamento.

Esses sistemas são amplamente utilizados em diversas plataformas, como serviços de streaming (Netflix, Spotify), e-commerce (Amazon), redes sociais (Instagram, Facebook) e outros serviços online.

Existem três tipos principais de sistemas de recomendação:



1.   Filtragem colaborativa: Esse método recomenda itens com base no comportamento de usuários semelhantes. Por exemplo, se o Usuário A gosta de filmes X e Y e o Usuário B gosta de filmes X, Y e Z, o sistema pode sugerir o filme Z para o Usuário A, com base na preferência do Usuário B.

2.   Filtragem baseada em conteúdo: Aqui, o sistema recomenda coisas baseadas nas suas preferências anteriores. Se você sempre assiste filmes de ação, o sistema vai sugerir mais filmes desse gênero.

3. Filtragem híbrida: Esse combina os dois métodos acima. Ou seja, ele leva em conta tanto o que você curte quanto o que outras pessoas com gostos parecidos gostam.

Um sistema de recomendação de livros é uma ferramenta que sugere livros para os leitores com base nos seus gostos e interesses. Ele usa informações sobre o que o usuário já leu ou pesquisou, além das preferências de outros leitores com gostos semelhantes, para oferecer sugestões personalizadas.

Fonte de Dados:

https://www.kaggle.com/datasets/rxsraghavagrawal/book-recommender-system

1º Problema de Negocio:

Usaremos o metodo de filtragem colaborativo para construir um sistema de recomendação de livros. Vamos construir uma maquina preditiva, com base nas escolhas de leituras de outras pessoas, o livro seja recomendado com base na semelhança de preferencias e interesses.

2º Analise Exploratoria dos Dados
"""

# Importação das Bibliotecas

import numpy as np
import pandas as pd
from sklearn.neighbors import NearestNeighbors

"""Base de LIvros"""

# Importação dos Dados Referentes aos Livros

books = pd.read_csv('BX-Books.csv', sep=';', encoding="latin-1", on_bad_lines='skip')

books

"""Base de Usuarios"""

# Importação dos Dados Referentes aos Usuarios

users = pd.read_csv('BX-Users.csv', sep=';', encoding="latin-1", on_bad_lines='skip')

users

"""Base Ratings"""

# Importação dos Dados Referentes aos Ratings (Avaliação do Usuario em Relação ao Livro)
ratings = pd.read_csv('BX-Book-Ratings.csv', sep=';', encoding='latin-1', on_bad_lines='skip')

ratings

"""3º Pré - Processamento de Dados

Renomeando Colunas

No arquivo de livros, temos algumas colunas extras que não são necessarias para a analise, como URLs de imagens. Vamos renomear as colunas de cada arquivo, pois o nome contém espaço e letras maiusculas, então faremos as correções para facilitar o uso.
"""

# Rename de Colunas

books = books [['ISBN', 'Book-Title', 'Book-Author', 'Year-Of-Publication', 'Publisher']]
books.rename(columns = {'Book-Title':'title', 'Book-Author':'author', 'Year-Of-Publication':'year', 'Publisher':'publisher'}, inplace=True)
users.rename(columns = {'User-ID':'user_id', 'Location':'location', 'Age':'age'}, inplace=True)
ratings.rename(columns = {'User-ID':'user_id', 'Book-Rating':'rating'}, inplace=True)

books

# Quantidade de Ratings por Usuarios
ratings['user_id'].value_counts()

# Livros que tenham mais de 200 avaliações
x = ratings['user_id'].value_counts() > 200

x

# Quantidade Usuários
#user_ids
y = x[x].index
print(y.shape)

y

"""Decisão de Negócio"""

# Trazendo Ratings somente os Usuários que aavaliaram mais de 200 livros
ratings = ratings[ratings['user_id'].isin(y)]

ratings

# Juntando tabelas (Merge)
rating_with_books = ratings.merge(books, on='ISBN')
rating_with_books.head()

# Quantidade de rating dos livros
number_rating = rating_with_books.groupby('title')['rating'].count().reset_index()

number_rating

# Renomeando Coluna
number_rating.rename(columns={'rating':'number_of_ratings'}, inplace=True)
number_rating

# Juntando a tabela de livros com os Ratings com a tabela de quantidade de ratings por livro
final_rating = rating_with_books.merge(number_rating, on='title')
final_rating

"""Decisão de Negócio

"""

# Filtrar somente livros que tenham pelo menos 50 avaliações
final_rating = final_rating[final_rating['number_of_ratings'] >= 50]
final_rating.shape

# Vamos descartar os valores duplicados, porque se o mesmo usuario tiver avaliado o mesmo livro várias vezes, isso pode afetar a analise.
final_rating.drop_duplicates(['user_id','title'], inplace=True)
final_rating.shape

final_rating

"""## Proximos Passos:

Vamos transpor os usuários em colunas, ao invés de linhas, pois as avaliações dadas por eles serão as variáveis da maquina preditiva
"""

final_rating.info()

# Transposição de linhas(users_id) em colunas
book_pivot = final_rating.pivot_table(columns='user_id', index='title', values="rating")

book_pivot

book_pivot.fillna(0, inplace=True)

book_pivot

"""Preparamos nosso conjunto de dados para modelagem. Usaremos o algoritimo de vizinhos mais proximos(nearest neighbords algorithm), que é usado para agrupamento com base na distância euclidiana.

Mas aqui na tabela dinâmica, temos muitos valores zero e no agrupamento, esse poder de computação aumentará para calcular a distância dos valores zeros, portanto, converteremos a tabela dinâmica para a matriz esparsa,e em seguida, alimentarmos o modelo
"""

!pip install scipy

from scipy.sparse import csr_matrix
book_sparse = csr_matrix(book_pivot)

"""4º Criação da Maquina Preditiva"""

from sklearn.neighbors import NearestNeighbors
model = NearestNeighbors(algorithm='brute')
model.fit(book_sparse)

"""Novas Predições"""

book_pivot.head(226)

#1984
distances, suggestions = model.kneighbors(book_pivot.iloc[0, :].values.reshape(1, -1))

for i in range(len(suggestions)):
  print(book_pivot.index[suggestions[i]])

# Bridget Jones's Diary
distances, suggestions = model.kneighbors(book_pivot.iloc[95, :].values.reshape(1, -1))

for i in range(len(suggestions)):
  print(book_pivot.index[suggestions[i]])

# Girl with a Pearl Earring
distances, suggestions = model.kneighbors(book_pivot.iloc[225, :].values.reshape(1, -1))

for i in range(len(suggestions)):
  print(book_pivot.index[suggestions[i]])

"""# Aplicações:

Em sistemas de recomendação, é usada para medir a similaridade entre usuários ou produtos.

Em machine learning, é usada para calcular proximidade entre pontos em algoritmos como o KNN (K-Nearest Neighbors).

Na computação gráfica, ajuda a determinar distâncias entre objetos no espaço.

Basicamente, quanto menor a distância euclidiana entre dois pontos, mais parecidos eles são dentro daquele contexto!

## Conclusão:

Ao implementar um sistema de recomendação eficaz, a empresa aumenta significativamente as taxas de conversão, oferecendo sugestões personalizadas que realmente interessam aos clientes. Isso impulsiona as vendas e contribui para o crescimento do faturamento, já que mais consumidores são atraídos por ofertas relevantes. Além disso, ao demonstrar um profundo entendimento das preferências do cliente, a empresa cria uma experiência de compra envolvente, resultando em maior satisfação e fidelização.

Para tornar esse processo mais preciso, muitas dessas recomendações utilizam a distância euclidiana, uma métrica que mede a similaridade entre usuários ou produtos.

Em machine learning, essa técnica é usada para calcular a proximidade entre pontos, como no algoritmo KNN (K-Nearest Neighbors).

Na computação gráfica, ela também ajuda a determinar distâncias entre objetos no espaço. Quanto menor a distância euclidiana entre dois pontos, maior a semelhança entre eles, permitindo que as recomendações sejam cada vez mais precisas e personalizadas.

Isso não só melhora a experiência do usuário, como também fortalece a marca e maximiza as receitas da empresa.
"""